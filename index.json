[{"content":"","date":"2025-03-13","externalUrl":null,"permalink":"/tags/%23%E7%BC%96%E7%A8%8B/","section":"Tags","summary":"","title":"#编程","type":"tags"},{"content":"","date":"2025-03-13","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"注意：习题都还没做，等到看完视频之后来做，并且更新一下八股文文档。\nLecture0：C++的历史和哲学 # C++的发展历史 # 汇编：unportable、hardtowrite C：no classes C++ ","date":"2025-03-13","externalUrl":null,"permalink":"/posts/cs106b/","section":"Posts","summary":"","title":"Cs106B","type":"posts"},{"content":"","date":"2025-03-13","externalUrl":null,"permalink":"/","section":"Lucia","summary":"","title":"Lucia","type":"page"},{"content":"","date":"2025-03-13","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025-03-13","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-03-13","externalUrl":null,"permalink":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/","section":"Categories","summary":"","title":"计算机","type":"categories"},{"content":"","date":"2023-08-14","externalUrl":null,"permalink":"/tags/%23space/","section":"Tags","summary":"","title":"#Space","type":"tags"},{"content":" A sub-title # Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi nibh nisl, vulputate eu lacus vitae, maximus molestie libero. Vestibulum laoreet, odio et sollicitudin sollicitudin, quam ligula tempus urna, sed sagittis eros eros ac felis. In tristique tortor vitae lacinia commodo. Mauris venenatis ultrices purus nec fermentum. Nunc sit amet aliquet metus. Morbi nisl felis, gravida ac consequat vitae, blandit eu libero. Curabitur porta est in dui elementum porttitor. Maecenas fermentum, tortor ac feugiat fringilla, orci sem sagittis massa, a congue risus ipsum vel massa. Aliquam sit amet nunc vulputate, facilisis neque in, faucibus nisl.\n","date":"2023-08-14","externalUrl":null,"permalink":"/posts/my-first-post/","section":"Posts","summary":"This is my first post on my site","title":"My first post","type":"posts"},{"content":" # CS106学习笔记\nLecture0：C++的历史和哲学 # C++的发展历史 # 汇编：unportable、hardtowrite C：no classes C++ — — — — — — A better C — — — — — — # Chapter 3：stream、types and advanced streams # stream：程序与其环境（即用户和文件系统）进行交互的主要手段\n不同的stream # cin、cout # 终端、键盘输入输出\n段落1:哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈还哈哈哈哈哈哈哈哈哈哈哈哈哈\n段落2:嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿\n段落3:嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻\n读到空格或换行符为止 或者读到任何不符合该type的字符为止，因此读取type是会影响读取的数量的！ ifstream、ofstream # 和磁盘中的文件交互\n创建： //文件名要用cstring格式，可用.c_str()转换 ifstream myStream(文件名);\t//方法1 ifstream myStream; myStream.open(文件名);\t//方法2 if(myStream.is_open()){……}; 读取和写入 读取：myStream \u0026raquo; myInteger 写入：注意ofstream会创建不存在的文件，或会覆盖原来的文件 关闭：读取后，用close关闭 getline # 读取文件的一行。更安全地读取文件的方式\ngetline的性质 getline(read_from stream, write_to stream)，会读到下一行位置 会强制转换类型为string，不会因为类型问题出错 getline vs cin cin会跳过空格和换行符 getline不会跳过空格，因此尽量不要混合使用两者，否则可能会造成一些问题 stringstream # 带buffer的stream，可以用词创建和读取string。是一个iostream（输入输出都行）\n关于stringstream的写入 stringstream可以在定义的时候附上初值，但后续写入会覆盖初值，如下图 可使用stringstream mystream(\u0026ldquo;initial value\u0026rdquo;, mode); mode处填写stringstream:: bin来实现追加 可以利用stringstream实现把数字直接放入string里，如 可以用.str()获取stringstream中的字符串 可以用stringstream实现输入和输出 注意，依然适用 \u0026raquo;的规则，如果读取和读取到的变量类型不匹配会报错 getline vs stringstream getline取出来的是string，不是formatted data stringstream可以直接取出对应类型的数据 [案例] 实现一个GetInteger函数 # 需求和需求分析\n需求 需求分析 读取输入 使用cin读取输入时，可能因为类型不匹配导致出错；此外，cin可能没法读全字符因此，使用getline来实现 处理输入，获取int getline获取的是字符串，而不是formatted data，因此使用stringstream来进行中转：stringstream \u0026laquo; getline()判断读取内容是否合法：1. 判断是否输入int，直接读取，\u0026raquo;会判断类型是否匹配，否则报错2. 判断是否有剩余字符，读取完int后，再读取到char里，看是否有剩余 [总结] # 形式的都会因为\u0026lt;u\u0026gt;读取类型不匹配报错\u0026lt;/u\u0026gt;+\u0026lt;u\u0026gt;有可能读不全\u0026lt;/u\u0026gt;（按token读取，且读到跟type不匹配的字符会停下），如cin ifstream istringstream；\n不受这些限制的是getline **** cin cout ifstream ofstream stringstream getline 简单描述 与console或keyboard的交互 和磁盘文件的交互 带buffer的stream 从stream读到stream 读取逻辑 读取一个token，会跳过空格或换行 读取一行 类型问题 会因为读取类型不匹配报错 会因为读取类型不匹配报错 会自动把读取内容转为string #define macroname(parameter) body\t//写下macros #include \u0026#34;filename.h\u0026#34; #undef macroname --- filename.h --- 在filename.h中定义引用的内容，这些内容和macroname匹配，被替换 #define PRINTOUT(n) cout \u0026lt;\u0026lt; #n \u0026lt;\u0026lt;\u0026#34;has value \u0026#34; \u0026lt;\u0026lt; (n) \u0026lt;\u0026lt; endl int x = 137; PRINTOUT(x * 42); ----- after preprocessing ------ int x = 137; cout \u0026lt;\u0026lt; \u0026#34;x * 42\u0026#34; \u0026lt;\u0026lt;\u0026#34;has value \u0026#34; \u0026lt;\u0026lt; (x * 42) \u0026lt;\u0026lt; endl; #define DECLARE_MY_VAR(type) type my_##type DECLARE_MY_VAR(int); ----- after preprocessing ------ int my_int; struct DFA { map\u0026lt;pair\u0026lt;int, char\u0026gt;, int\u0026gt; transitions; set\u0026lt;int\u0026gt; acceptingStates; int startState; }; /* 接收一个DFA和string，判断string是否可以被接受*/ bool SimulateDFA(DFA\u0026amp; d, string input) { int currState = d.startState; for(string::iterator itr = input.begin(); itr != input.end(); ++itr) currState = d.transitions[make_pair(currState, *itr)]; //string是否结束于accepting state return d.acceptingStates.find(currState) != d.acceptingStates.end(); } vector\u0026lt;int\u0026gt; myVector; back_insert_iterator\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; itr(myVector);//主要看（）里的内容就行，类型是根据写入位置来确定的，可以简写 for (int i = 0; i \u0026lt; 10; ++i) { *itr = i; // \u0026#34;Write\u0026#34; to the back_insert_iterator, appending the value. ++itr; } /* Print the vector contents; this displays 0 1 2 3 4 5 6 7 8 9 */ copy(myVector.begin(), myVector.end(), ostream_iterator\u0026lt;int\u0026gt;(cout, \u0026#34; \u0026#34;)); back_insert_iterator\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; itr(myVector);//主要看（）里的内容就行，类型是根据写入位置来确定的，可以简写 for (int i = 0; i \u0026lt; 10; ++i) { *itr = i; // \u0026#34;Write\u0026#34; to the back_insert_iterator, appending the value. ++itr; } /* Print the vector contents; this displays 0 1 2 3 4 5 6 7 8 9 */ copy(myVector.begin(), myVector.end(), ostream_iterator\u0026lt;int\u0026gt;(cout, \u0026#34; \u0026#34;)); back_insert_iterator\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; itr(myVector);//主要看（）里的内容就行，类型是根据写入位置来确定的，可以简写 for (int i = 0; i \u0026lt; 10; ++i) { *itr = i; // \u0026#34;Write\u0026#34; to the back_insert_iterator, appending the value. ++itr; } /* Print the vector contents; this displays 0 1 2 3 4 5 6 7 8 9 */ copy(myVector.begin(), myVector.end(), ostream_iterator\u0026lt;int\u0026gt;(cout, \u0026#34; \u0026#34;)); back_insert_iterator\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; itr(myVector);//主要看（）里的内容就行，类型是根据写入位置来确定的，可以简写 for (int i = 0; i \u0026lt; 10; ++i) { *itr = i; // \u0026#34;Write\u0026#34; to the back_insert_iterator, appending the value. ++itr; } /* Print the vector contents; this displays 0 1 2 3 4 5 6 7 8 9 */ copy(myVector.begin(), myVector.end(), ostream_iterator\u0026lt;int\u0026gt;(cout, \u0026#34; \u0026#34;)); vector\u0026lt;int\u0026gt; original = /* ... */ vector\u0026lt;int\u0026gt; destination; reverse_copy(original.begin(), original.end(), back_insert_iterator\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt;(destination)); //可以简写为back_inserter(destination) ","externalUrl":null,"permalink":"/posts/cs106l/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/archives/","section":"Lucia","summary":"archives","title":"Archive","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/search/","section":"Lucia","summary":"search","title":"搜索","type":"page"}]