<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cs106L | My New Hugo Site</title>
<meta name=keywords content><meta name=description content="注意：习题都还没做，等到看完视频之后来做，并且更新一下八股文文档。
Lecture0：C++的历史和哲学
C++的发展历史

汇编：unportable、hardtowrite
C：no classes
C++

— — — — — —   A better C   — — — — — —
Chapter 3：stream、types and advanced streams
stream：程序与其环境（即用户和文件系统）进行交互的主要手段
不同的stream
cin、cout

终端、键盘输入输出
不是很安全，有可能读不全（导致后续的读取出现错误），也不提供安全检查

读到空格或换行符为止
或者读到任何不符合该type的字符为止，因此读取type是会影响读取的数量的！

ifstream、ofstream

和磁盘中的文件交互

创建：

//文件名要用cstring格式，可用.c_str()转换
ifstream myStream(文件名);    //方法1

ifstream myStream; 
myStream.open(文件名);        //方法2
if(myStream.is_open()){……};

读取和写入

读取：myStream &#187; myInteger
写入：注意ofstream会创建不存在的文件，或会覆盖原来的文件


关闭：读取后，用close关闭

getline

读取文件的一行。更安全地读取文件的方式"><meta name=author content><link rel=canonical href=https://example.org/posts/cs106l/><link crossorigin=anonymous href=/assets/css/stylesheet.387a99fa4f06a87aae06b142542a820c90759c9c092a9089cbe9a8ecbd7c0f35.css integrity="sha256-OHqZ+k8GqHquBrFCVCqCDJB1nJwJKpCJy+mo7L18DzU=" rel="preload stylesheet" as=style><link rel=icon href=https://example.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://example.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://example.org/favicon-32x32.png><link rel=apple-touch-icon href=https://example.org/apple-touch-icon.png><link rel=mask-icon href=https://example.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://example.org/posts/cs106l/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://example.org/posts/cs106l/"><meta property="og:site_name" content="My New Hugo Site"><meta property="og:title" content="Cs106L"><meta property="og:description" content="注意：习题都还没做，等到看完视频之后来做，并且更新一下八股文文档。
Lecture0：C++的历史和哲学 C++的发展历史 汇编：unportable、hardtowrite C：no classes C++ — — — — — — A better C — — — — — — Chapter 3：stream、types and advanced streams stream：程序与其环境（即用户和文件系统）进行交互的主要手段
不同的stream cin、cout 终端、键盘输入输出
不是很安全，有可能读不全（导致后续的读取出现错误），也不提供安全检查
读到空格或换行符为止 或者读到任何不符合该type的字符为止，因此读取type是会影响读取的数量的！ ifstream、ofstream 和磁盘中的文件交互
创建： //文件名要用cstring格式，可用.c_str()转换 ifstream myStream(文件名); //方法1 ifstream myStream; myStream.open(文件名); //方法2 if(myStream.is_open()){……}; 读取和写入 读取：myStream » myInteger 写入：注意ofstream会创建不存在的文件，或会覆盖原来的文件 关闭：读取后，用close关闭 getline 读取文件的一行。更安全地读取文件的方式"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-13T13:42:19+08:00"><meta property="article:modified_time" content="2025-03-13T13:42:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cs106L"><meta name=twitter:description content="注意：习题都还没做，等到看完视频之后来做，并且更新一下八股文文档。
Lecture0：C++的历史和哲学
C++的发展历史

汇编：unportable、hardtowrite
C：no classes
C++

— — — — — —   A better C   — — — — — —
Chapter 3：stream、types and advanced streams
stream：程序与其环境（即用户和文件系统）进行交互的主要手段
不同的stream
cin、cout

终端、键盘输入输出
不是很安全，有可能读不全（导致后续的读取出现错误），也不提供安全检查

读到空格或换行符为止
或者读到任何不符合该type的字符为止，因此读取type是会影响读取的数量的！

ifstream、ofstream

和磁盘中的文件交互

创建：

//文件名要用cstring格式，可用.c_str()转换
ifstream myStream(文件名);    //方法1

ifstream myStream; 
myStream.open(文件名);        //方法2
if(myStream.is_open()){……};

读取和写入

读取：myStream &#187; myInteger
写入：注意ofstream会创建不存在的文件，或会覆盖原来的文件


关闭：读取后，用close关闭

getline

读取文件的一行。更安全地读取文件的方式"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://example.org/posts/"},{"@type":"ListItem","position":2,"name":"Cs106L","item":"https://example.org/posts/cs106l/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cs106L","name":"Cs106L","description":"注意：习题都还没做，等到看完视频之后来做，并且更新一下八股文文档。\nLecture0：C++的历史和哲学 C++的发展历史 汇编：unportable、hardtowrite C：no classes C++ — — — — — — A better C — — — — — — Chapter 3：stream、types and advanced streams stream：程序与其环境（即用户和文件系统）进行交互的主要手段\n不同的stream cin、cout 终端、键盘输入输出\n不是很安全，有可能读不全（导致后续的读取出现错误），也不提供安全检查\n读到空格或换行符为止 或者读到任何不符合该type的字符为止，因此读取type是会影响读取的数量的！ ifstream、ofstream 和磁盘中的文件交互\n创建： //文件名要用cstring格式，可用.c_str()转换 ifstream myStream(文件名); //方法1 ifstream myStream; myStream.open(文件名); //方法2 if(myStream.is_open()){……}; 读取和写入 读取：myStream \u0026raquo; myInteger 写入：注意ofstream会创建不存在的文件，或会覆盖原来的文件 关闭：读取后，用close关闭 getline 读取文件的一行。更安全地读取文件的方式\n","keywords":[],"articleBody":"注意：习题都还没做，等到看完视频之后来做，并且更新一下八股文文档。\nLecture0：C++的历史和哲学 C++的发展历史 汇编：unportable、hardtowrite C：no classes C++ — — — — — — A better C — — — — — — Chapter 3：stream、types and advanced streams stream：程序与其环境（即用户和文件系统）进行交互的主要手段\n不同的stream cin、cout 终端、键盘输入输出\n不是很安全，有可能读不全（导致后续的读取出现错误），也不提供安全检查\n读到空格或换行符为止 或者读到任何不符合该type的字符为止，因此读取type是会影响读取的数量的！ ifstream、ofstream 和磁盘中的文件交互\n创建： //文件名要用cstring格式，可用.c_str()转换 ifstream myStream(文件名); //方法1 ifstream myStream; myStream.open(文件名); //方法2 if(myStream.is_open()){……}; 读取和写入 读取：myStream » myInteger 写入：注意ofstream会创建不存在的文件，或会覆盖原来的文件 关闭：读取后，用close关闭 getline 读取文件的一行。更安全地读取文件的方式\ngetline的性质 getline(read_from stream, write_to stream)，会读到下一行位置 会强制转换类型为string，不会因为类型问题出错 getline vs cin cin会跳过空格和换行符 getline不会跳过空格，因此尽量不要混合使用两者，否则可能会造成一些问题 stringstream 带buffer的stream，可以用词创建和读取string。是一个iostream（输入输出都行）\n关于stringstream的写入 stringstream可以在定义的时候附上初值，但后续写入会覆盖初值，如下图 可使用stringstream mystream(“initial value”, mode); mode处填写stringstream:: bin来实现追加 可以利用stringstream实现把数字直接放入string里，如 可以用.str()获取stringstream中的字符串 可以用stringstream实现输入和输出 注意，依然适用 »的规则，如果读取和读取到的变量类型不匹配会报错 getline vs stringstream getline取出来的是string，不是formatted data stringstream可以直接取出对应类型的数据 [案例] 实现一个GetInteger函数 需求和需求分析\n需求 需求分析 读取输入 使用cin读取输入时，可能因为类型不匹配导致出错；此外，cin可能没法读全字符因此，使用getline来实现 处理输入，获取int getline获取的是字符串，而不是formatted data，因此使用stringstream来进行中转：stringstream « getline()判断读取内容是否合法：1. 判断是否输入int，直接读取，»会判断类型是否匹配，否则报错2. 判断是否有剩余字符，读取完int后，再读取到char里，看是否有剩余 [总结] 形式的都会因为读取类型不匹配报错+有可能读不全（按token读取，且读到跟type不匹配的字符会停下），如cin ifstream istringstream；\n不受这些限制的是getline **** cin cout ifstream ofstream stringstream getline 简单描述 与console或keyboard的交互 和磁盘文件的交互 带buffer的stream 从stream读到stream 读取逻辑 读取一个token，会跳过空格或换行 读取一行 类型问题 会因为读取类型不匹配报错 会因为读取类型不匹配报错 会自动把读取内容转为string 流和缓冲 4种标准IOstream和它们与缓冲的关系\n用cout来演示buffered stream的效果\ncout \u003c\u003c \"CS\"; somethingspendtime(); cout \u003c\u003c \"106\"; somethingspendtime(); cout \u003c\u003c \"L\"; somethingspendtime(); cout \u003c\u003c endl; “CS106L\"会同时打印到控制台上，而不是CS、106、L这样打印三次。\n实际上，标准输入输出的开销是十分昂贵的（注：这实际上涉及到系统调用，从用户态到内核态的切换等，开销很大），因此cout流会在buffer满或强制刷新buffer的时候将buffer内的字符一齐输出到控制台上。\n注意：\n但标准错误流不会进行缓冲std::cerr流会直接输出。（这点和python是一样的）。 实际上，有一些操作是会自动触发buffer的刷新的，如cin，在用户输入之前应该把cout buffer内的数据输出到控制台。 stream manipulators «, » ：stream insertion/extraction operator endl：行终止，打印新的行字符 setw：设置字段宽度。如cout « ‘[’ « left « setw(10) « “hello!” « endl;在左边填充空格 setfill：和setw一起用，更改填充的字符。如setfill(‘0’)，设置后后面的流使用setw时都将用'0‘填充 boolalpha：显示true/false而不是0或1 hex\\dec\\oct：设置显示进制 ws：跳过流中的空格（注意，»stream extraction会自动忽略空格，但getline之类的函数不会，ws可以和这些函数一起使用） 错误 错误原因\n当 » 的内容和变量不匹配或者是没有数据可读的情况，就会出错。\n错误的判断和处理\n可通过.fail()来判断是否有错误，并用.clear()消除错误（但clear不会跳过令你出错的字符，需要手动处理那些字符） 的表达式本身也会返回true/false，可作为while()的判断，如while(myStream » myInt » myStr){……}\nMore to explore 随机读取：上述提到的都是顺序读取的方法，需要随机读取时（比如读zip中的指定文件）可使用seekg，tellg，seekp，tellp等函数 read write：减少写入数字时应编码造成的空间浪费并提高效率 write：writes unformatted data to a stream read：reads unformatted data from a stream into memory Chapter 4：Multifile Programs, Abstraction, and the Preprocessor C++编译模型 编译的步骤（这里应该是把编译过程包括了汇编）\npreprocessing（预处理）：展开代码。include、FILE、#define constant、macros compliation（编译）：优化并转换成机器码，本阶段会报语法错误。 linking（链接）：链接多个文件形成可执行程序。 关于linking错误：只声明但未定义函数（编译阶段不报错的原因是，函数声明和定义可以在不同的文件中）、函数传参方式不同（） 头文件和实现文件 abstraction：软件实现是很复杂的，可以使用abstraction的方法来简化实现，分离 (how it solved) and (how to use it)，这会使得程序具有simplicity、extensibility和reusability。abstraction的一个例子是头文件和实现文件，分离定义和实现。\n头文件和预处理器 建议：应当尽量使用新的语言特性来减少preprocessing的使用\ninclude 作用：preprocessor会把include的内容直接插入到指令中去 关于include \u003c\u003e 和 include “”：\u003c\u003e寻找C++标准库，““寻找当前目录 关于include的格式：必须是顶格、单行、无分号 include guard 作用：防止重复展开头文件\n#ifdef File_Included #define File_Included …… #endif ","wordCount":"248","inLanguage":"en","datePublished":"2025-03-13T13:42:19+08:00","dateModified":"2025-03-13T13:42:19+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://example.org/posts/cs106l/"},"publisher":{"@type":"Organization","name":"My New Hugo Site","logo":{"@type":"ImageObject","url":"https://example.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://example.org/ accesskey=h title="My New Hugo Site (Alt + H)">My New Hugo Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Cs106L</h1><div class=post-meta><span title='2025-03-13 13:42:19 +0800 +0800'>March 13, 2025</span></div></header><div class=post-content><p><strong>注意：习题都还没做，等到看完视频之后来做，并且更新一下八股文文档。</strong></p><h2 id=lecture0c的历史和哲学>Lecture0：C++的历史和哲学<a hidden class=anchor aria-hidden=true href=#lecture0c的历史和哲学>#</a></h2><h3 id=c的发展历史>C++的发展历史<a hidden class=anchor aria-hidden=true href=#c的发展历史>#</a></h3><ul><li>汇编：unportable、hardtowrite</li><li>C：no classes</li><li>C++</li></ul><h1 id=--------a-better-c-------->— — — — — — A better C — — — — — —<a hidden class=anchor aria-hidden=true href=#--------a-better-c-------->#</a></h1><h2 id=chapter-3streamtypes-and-advanced-streams>Chapter 3：stream、types and advanced streams<a hidden class=anchor aria-hidden=true href=#chapter-3streamtypes-and-advanced-streams>#</a></h2><p>stream：程序与其环境（即用户和文件系统）进行交互的主要手段</p><h3 id=不同的stream>不同的stream<a hidden class=anchor aria-hidden=true href=#不同的stream>#</a></h3><h4 id=cincout>cin、cout<a hidden class=anchor aria-hidden=true href=#cincout>#</a></h4><blockquote><p>终端、键盘输入输出</p></blockquote><p>不是很安全，有可能读不全（导致后续的读取出现错误），也不提供安全检查</p><ul><li>读到空格或换行符为止</li><li>或者读到任何不符合该type的字符为止，因此读取type是会影响读取的数量的！</li></ul><h4 id=ifstreamofstream>ifstream、ofstream<a hidden class=anchor aria-hidden=true href=#ifstreamofstream>#</a></h4><blockquote><p>和磁盘中的文件交互</p></blockquote><ul><li><strong>创建</strong>：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//文件名要用cstring格式，可用.c_str()转换
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ifstream <span style=color:#a6e22e>myStream</span>(<span style=color:#960050;background-color:#1e0010>文件名</span>);    <span style=color:#75715e>//方法1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>ifstream myStream; 
</span></span><span style=display:flex><span>myStream.open(<span style=color:#960050;background-color:#1e0010>文件名</span>);        <span style=color:#75715e>//方法2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>(myStream.is_open()){<span style=color:#960050;background-color:#1e0010>……</span>};
</span></span></code></pre></div><ul><li><strong>读取和写入</strong><ul><li>读取：myStream &#187; myInteger</li><li>写入：注意ofstream会创建不存在的文件，或会覆盖原来的文件</li></ul></li><li><strong>关闭</strong>：读取后，用close关闭</li></ul><h4 id=getline>getline<a hidden class=anchor aria-hidden=true href=#getline>#</a></h4><blockquote><p>读取文件的一行。更安全地读取文件的方式</p></blockquote><ul><li><strong>getline的性质</strong><ul><li>getline(read_from stream, write_to stream)，会读到下一行位置</li><li>会强制转换类型为string，不会因为类型问题出错</li></ul></li><li><strong>getline vs cin</strong><ul><li>cin会跳过空格和换行符</li><li>getline不会跳过空格，因此尽量不要混合使用两者，否则可能会造成一些问题</li></ul></li></ul><h4 id=stringstream>stringstream<a hidden class=anchor aria-hidden=true href=#stringstream>#</a></h4><blockquote><p>带buffer的stream，可以用词创建和读取string。是一个iostream（输入输出都行）</p></blockquote><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2023/png/12798414/1695964295046-2bca9095-fc0d-4248-bcaf-15a8b2287115.png></p><ul><li>关于stringstream的写入<ul><li>stringstream可以在定义的时候附上初值，但后续写入会覆盖初值，如下图</li><li>可使用stringstream mystream(&ldquo;initial value&rdquo;, mode); mode处填写stringstream:: bin来实现追加</li><li><img loading=lazy src=https://cdn.nlark.com/yuque/0/2023/png/12798414/1682301323579-bd1e7318-4253-4db7-9a2f-11f472748edd.png></li></ul></li><li>可以利用stringstream实现把数字直接放入string里，如</li></ul><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2023/png/12798414/1681999684352-ae974720-720e-4be3-88ec-b163fa86ed2d.png></p><ul><li>可以用.str()获取stringstream中的字符串</li><li>可以用stringstream实现输入和输出<ul><li>注意，依然适用 &#187;的规则，如果读取和读取到的变量类型不匹配会报错</li></ul></li><li>getline vs stringstream<ul><li>getline取出来的是string，不是formatted data</li><li>stringstream可以直接取出对应类型的数据</li></ul></li></ul><h4 id=案例-实现一个getinteger函数>[案例] 实现一个GetInteger函数<a hidden class=anchor aria-hidden=true href=#案例-实现一个getinteger函数>#</a></h4><p>需求和需求分析</p><table><thead><tr><th>需求</th><th>需求分析</th></tr></thead><tbody><tr><td>读取输入</td><td>使用cin读取输入时，可能因为类型不匹配导致出错；此外，cin可能没法读全字符因此，使用getline来实现</td></tr><tr><td>处理输入，获取int</td><td>getline获取的是字符串，而不是formatted data，因此使用stringstream来进行中转：stringstream &#171; getline()判断读取内容是否合法：1. 判断是否输入int，直接读取，&#187;会判断类型是否匹配，否则报错2. 判断是否有剩余字符，读取完int后，再读取到char里，看是否有剩余</td></tr></tbody></table><h4 id=总结>[总结]<a hidden class=anchor aria-hidden=true href=#总结>#</a></h4><ul><li><blockquote><blockquote><p>形式的都会因为<code>&lt;u>读取类型不匹配报错&lt;/u></code>+<code>&lt;u>有可能读不全&lt;/u></code>（按token读取，且读到跟type不匹配的字符会停下），如cin ifstream istringstream；</p></blockquote></blockquote></li><li>不受这些限制的是getline</li></ul><table><thead><tr><th>****</th><th><strong>cin cout</strong></th><th><strong>ifstream ofstream</strong></th><th><strong>stringstream</strong></th><th><strong>getline</strong></th></tr></thead><tbody><tr><td><strong>简单描述</strong></td><td>与console或keyboard的交互</td><td>和磁盘文件的交互</td><td>带buffer的stream</td><td>从stream读到stream</td></tr><tr><td><strong>读取逻辑</strong></td><td>读取一个token，会跳过空格或换行</td><td></td><td></td><td>读取一行</td></tr><tr><td><strong>类型问题</strong></td><td>会因为读取类型不匹配报错</td><td></td><td>会因为读取类型不匹配报错</td><td>会自动把读取内容转为string</td></tr></tbody></table><h3 id=流和缓冲>流和缓冲<a hidden class=anchor aria-hidden=true href=#流和缓冲>#</a></h3><p>4种标准IOstream和它们与缓冲的关系</p><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2023/png/12798414/1682303991279-cd120255-028f-4210-b2e1-b49debe2886f.png></p><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2023/webp/12798414/1682303775936-b919ba32-a651-4e27-b67a-14f877d4d1a6.webp></p><p>用cout来演示buffered stream的效果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;CS&#34;</span>;
</span></span><span style=display:flex><span>somethingspendtime();
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;106&#34;</span>;
</span></span><span style=display:flex><span>somethingspendtime();
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;L&#34;</span>;
</span></span><span style=display:flex><span>somethingspendtime();
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span></code></pre></div><p>&ldquo;CS106L"会同时打印到控制台上，而不是CS、106、L这样打印三次。</p><blockquote><p>实际上，标准输入输出的开销是十分昂贵的（注：这实际上涉及到系统调用，从用户态到内核态的切换等，开销很大），因此cout流会在buffer满或强制刷新buffer的时候将buffer内的字符一齐输出到控制台上。</p></blockquote><p>注意：</p><ul><li>但标准错误流不会进行缓冲std::cerr流会直接输出。（这点和python是一样的）。</li><li>实际上，有一些操作是会自动触发buffer的刷新的，如cin，在用户输入之前应该把cout buffer内的数据输出到控制台。</li></ul><h3 id=stream-manipulators>stream manipulators<a hidden class=anchor aria-hidden=true href=#stream-manipulators>#</a></h3><ol><li>&#171;, &#187; ：stream insertion/extraction operator</li><li>endl：行终止，打印新的行字符</li><li>setw：设置字段宽度。如cout &#171; &lsquo;[&rsquo; &#171; left &#171; setw(10) &#171; &ldquo;hello!&rdquo; &#171; endl;在左边填充空格</li><li>setfill：和setw一起用，更改填充的字符。如setfill(&lsquo;0&rsquo;)，设置后后面的流使用setw时都将用'0‘填充</li><li>boolalpha：显示true/false而不是0或1</li><li>hex\dec\oct：设置显示进制</li><li>ws：跳过流中的空格（注意，&#187;stream extraction会自动忽略空格，但getline之类的函数不会，ws可以和这些函数一起使用）</li></ol><h3 id=错误>错误<a hidden class=anchor aria-hidden=true href=#错误>#</a></h3><p><strong>错误原因</strong></p><p>当 &#187; 的内容和变量不匹配或者是没有数据可读的情况，就会出错。</p><p><strong>错误的判断和处理</strong></p><ul><li>可通过.fail()来判断是否有错误，并用.clear()消除错误（但clear不会跳过令你出错的字符，需要手动处理那些字符）</li><li><blockquote><blockquote><p>的表达式本身也会返回true/false，可作为while()的判断，如while(myStream &#187; myInt &#187; myStr){……}</p></blockquote></blockquote></li></ul><h3 id=more-to-explore>More to explore<a hidden class=anchor aria-hidden=true href=#more-to-explore>#</a></h3><ul><li>随机读取：上述提到的都是顺序读取的方法，需要随机读取时（比如读zip中的指定文件）可使用seekg，tellg，seekp，tellp等函数</li><li>read write：减少写入数字时应编码造成的空间浪费并提高效率<ul><li>write：writes unformatted data to a stream</li><li>read：reads unformatted data from a stream into memory</li></ul></li></ul><h2 id=chapter-4multifile-programs-abstraction-and-the-preprocessor>Chapter 4：Multifile Programs, Abstraction, and the Preprocessor<a hidden class=anchor aria-hidden=true href=#chapter-4multifile-programs-abstraction-and-the-preprocessor>#</a></h2><h3 id=c编译模型>C++编译模型<a hidden class=anchor aria-hidden=true href=#c编译模型>#</a></h3><p>编译的步骤（这里应该是把编译过程包括了汇编）</p><ol><li>preprocessing（预处理）：展开代码。include、<em>FILE</em>、#define constant、macros</li><li>compliation（编译）：优化并转换成机器码，本阶段会报语法错误。</li><li>linking（链接）：链接多个文件形成可执行程序。<ol><li>关于linking错误：只声明但未定义函数（编译阶段不报错的原因是，函数声明和定义可以在不同的文件中）、函数传参方式不同（）</li></ol></li></ol><h3 id=头文件和实现文件>头文件和实现文件<a hidden class=anchor aria-hidden=true href=#头文件和实现文件>#</a></h3><p>abstraction：软件实现是很复杂的，可以使用abstraction的方法来简化实现，分离 (how it solved) and (how to use it)，这会使得程序具有simplicity、extensibility和reusability。abstraction的一个例子是头文件和实现文件，分离定义和实现。</p><h3 id=头文件和预处理器>头文件和预处理器<a hidden class=anchor aria-hidden=true href=#头文件和预处理器>#</a></h3><p>建议：应当尽量使用新的语言特性来减少preprocessing的使用</p><h4 id=include>include<a hidden class=anchor aria-hidden=true href=#include>#</a></h4><ul><li><strong>作用</strong>：preprocessor会把include的内容直接插入到指令中去</li><li><strong>关于include &lt;> 和 include &ldquo;&rdquo;</strong>：&lt;>寻找C++标准库，&ldquo;&ldquo;寻找当前目录</li><li><strong>关于include的格式</strong>：必须是顶格、单行、无分号</li></ul><h4 id=include-guard>include guard<a hidden class=anchor aria-hidden=true href=#include-guard>#</a></h4><p>作用：防止重复展开头文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifdef File_Included
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define File_Included
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>……</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://example.org/>My New Hugo Site</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>